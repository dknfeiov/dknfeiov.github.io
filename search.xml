<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Angular-React比较]]></title>
    <url>%2F2018%2F05%2F26%2FAngular-React%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[示例代码皆为伪代码，仅供理解 Angular 模块化、组件化、依赖注入、脏检查 Angular应用是模块化的， 一个NgModule就是一个容器，存放一些内聚代码块，如组件、指令、服务、管道等，提供导入、导出功能，每个Angular应用都会有一个根模块，引导根模块启动项目 组件可以通过路由器加载，也可以通过模板创建，组件是指令的一种，是带模版的指令，除了组件外，指令还有结构型指令和功能型指令二种，指令拥有生命周期钩子函数。在生命周期不同阶段被调用 依赖注入机制，注入器是树形结构，注入的服务是单例，子模块中定义的provider将被注册到根注入器，除非子模块为懒加载，懒加载模块单独生成一个注入器，除此之外，组件也拥有组件级注入器 Angular脏检查由ngZone触发，zone重写了一系列异步方法，如事件、定时器、封装了ajax请求，添加了回调钩子函数，在回调中进行数据变更检查，为组件设置onPush策略，组件将只在Input数据发生变化时触发检查，组件可注入changeDetection手动设置脏检查机制 其他，路由、HttpCLient + 拦截器机制， 视图封装模式（Native、Emulated、None），动态组件、dom操作（Renderer）、Rxjs管理异步事件流 React 组件化、函数式编程、虚拟dom React 维护一颗组件树， 数据通过props从上往下单向流动，组件内部通过state保存状态，通过setState改变state的值，默认当props或state发生变化，组件重新渲染，PureReactComponent组件默认判断新旧props,state（浅引用判断）值，如果没有变化，不重新渲染，但过多diff操作同样消耗性能， 普通Component 可通过使用 shouldComponentUpdate生命周期钩子，返回true|false 来决定是否重新渲染组件，二者结合 immutable 对象性能更佳 React 组件有3种创建方式（函数式、ES6、ES5），函数式无状态组件拥有更好的性能，但如果需要用到state 、组件生命周期，则需要使用ES6方式, 通过ES5语法创建现已不推荐使用 二者差异 数据流向： Angular 数据从上往下，单向流动，通过Output自定义事件与父组件通信 ， React 通过props从上往下，数据单向流动，通过state保存当前组件内部的状态，通过setState改变组件内部状态，与父组件通信通常通过状态提升来完成，或使用redux 不可变性： @Input 、props 传递的数据都是不可变的（Angular官方文档并没有明确提示，但我从来没这么写过，就算可以也不建议，如果一定要对@Input传递的数据进行处理，可以用set去实现） Angular 中的结构型指令如ngIf、ngFor , React通过如下jsx语法实现同样的功能 1var &amp;&amp; &lt;div&gt;、datas.map(i,v) Angular 表单提供二种方式，模板驱动与响应式表单，前者通过模板语法与指令实现，后者由模型驱动，预先定义字段、校验项、初始值，提供校验方法，React 表单一般通过受控组件的方式实现 React 组件的props.children 类似于 Angular 的内容映射(通过ng-content指令实现) 避免重复渲染，性能优化，React 通常使用 shouldComponentUpdate + Immutable 对象减少重复渲染， Angular通常设置 changedetectionstrategy.onpush + Immutable 对象 获取Dom对象，React使用 refs传递，Angular 通过ViewChild实现对dom节点的引用 12345678React : &lt;div ref=&#123;domRef&#125;&gt; // 通过this.domRef获取dom节点Angular : .ts: ViewChild(selector) domRef .html: &lt;div seletor&gt;]]></content>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular实现元素双击可编辑]]></title>
    <url>%2F2018%2F02%2F28%2FAngular%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E5%8F%8C%E5%87%BB%E5%8F%AF%E7%BC%96%E8%BE%91%2F</url>
    <content type="text"><![CDATA[实现目标 新建指令，将指令注册为表单控件，在元素上使用，可以通过ngModel实现双向绑定，双击可编辑元素内文字内容，失去焦点不可编辑 使用1&lt;div appCanEdit [(ngModel)]="item.value"&gt;&lt;/div&gt; 效果 实现步骤1. 创建指令，实现 ControlValueAccessor接口 ControlValueAccessor是一个连接表单模型和视图（DOM元素）的接口，自定义的表单控件必须实现这个接口,它的作用是把 form 模型中值映射到视图中，当视图发生变化时，通知 form directives 或 form controls 12345678910111213141516171819202122232425@Directive(&#123; selector: '[appCanEdit]'&#125;)export class ElementCanEditDirective implements ControlValueAccessor &#123; _value; // callback function propagateChange = (value: any) =&gt; &#123; &#125;; // Writes a new value to the element ，temporarily store the value in '_value' writeValue(value: any) &#123; if (value) &#123; this._value = value; &#125; &#125; // when the control's value changes in the UI, call the callback function registerOnChange(fn: any) &#123; this.propagateChange = fn; &#125; registerOnTouched(fn: any) &#123; &#125; constructor( ) &#123; &#125;&#125; 2. 注册成为表单控件，将控件本身注册到DI框架成为一个可以让表单访问其值的控件12345678910@Directive(&#123; selector: '[appCanEdit]', providers: [ &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; ElementCanEditDirective), multi: true &#125; ],&#125;) 3. 通过@HostListener 为组件添加事件绑定，通过@HostBinding实现元素innerText随value而变化 当元素处于可编辑状态时，添加content-editable类样式，以便灵活控制样式 123456789101112131415161718192021@HostBinding() get innerText() &#123; return this._value;&#125;@HostListener('blur', ['$event.target'])onBlur(ele: HTMLElement) &#123; ele.contentEditable = 'false'; this._value = ele.innerText; this.propagateChange(this._value); this.render.removeClass(ele, 'content-editable');&#125;@HostListener('dblclick', ['$event.target'])dbClick(ele: HTMLElement) &#123; // plaintext-only ele.contentEditable = 'true'; ele.innerText = ele.innerText; ele.focus(); this.render.addClass(ele, 'content-editable');&#125; 完整代码1&lt;div appCanEdit [(ngModel)]="item.value"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import &#123; Component, OnInit, Input, EventEmitter, Directive, HostListener, HostBinding, Renderer2, forwardRef &#125; from '@angular/core';import &#123; ControlValueAccessor, NG_VALUE_ACCESSOR &#125; from '@angular/forms';/** * 让DOM元素可编辑 * 可在元素上使用 ngModel * @export * @class ElementCanEditDirective * @implements &#123;ControlValueAccessor&#125; */@Directive(&#123; selector: '[appCanEdit]', providers: [ &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; ElementCanEditDirective), multi: true &#125; ],&#125;)export class ElementCanEditDirective implements ControlValueAccessor &#123; _value; // callback function propagateChange = (value: any) =&gt; &#123; &#125;; // Writes a new value to the element ，temporarily store the value in '_value' writeValue(value: any) &#123; if (value) &#123; this._value = value; &#125; &#125; // when the control's value changes in the UI, call the callback function registerOnChange(fn: any) &#123; this.propagateChange = fn; &#125; registerOnTouched(fn: any) &#123; &#125; @HostBinding() get innerText() &#123; return this._value; &#125; @HostListener('blur', ['$event.target']) onBlur(ele: HTMLElement) &#123; ele.contentEditable = 'false'; this._value = ele.innerText; this.propagateChange(this._value); this.render.removeClass(ele, 'content-editable'); &#125; @HostListener('dblclick', ['$event.target']) dbClick(ele: HTMLElement) &#123; ele.contentEditable = 'true'; ele.innerText = ele.innerText; ele.focus(); this.render.addClass(ele, 'content-editable'); &#125; constructor( private render: Renderer2 ) &#123; &#125;&#125;]]></content>
      <tags>
        <tag>Angular , React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs到Angular的变化]]></title>
    <url>%2F2017%2F10%2F28%2FAngularJs%E5%88%B0Angular%E7%9A%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[以下只是个人使用过程中的的一些感受,具体二者之间的差别参考 官方文档 Typescript es6超集 , 支持 import export , 不需额外引入模块加载器 将组件和指令二者剥离开来，前者组成页面，后者分为结构性指令和功能性指令，不再支持replace等 移除controller, $scope等 provider，service,factory 统一为 service, 减少理解上的困惑 angularJs 只有一个注入器，所有服务都是单例，Angular的注入器则是一个树状结构，可以为一个注入对象实现不同的实例（在不同的注入器上） controller &lt;=&gt; component 一定意义上等价，都封装了model实体模型，指定html模板,业务逻辑，也都挂靠在模块上 在setTimeout等异步执行环境中不再需要手动调用$scope.$apply() , angular的代码都运行在 zone中，通过为异步方法打补丁的方式，在方法执行完后自动的执行数据检查，如果使用第三方类库，存在异步操作，想要纳入Angular管理，可以通过以下方式实现 123this.ngZone.run(() =&gt; &#123; this.service.uploadEvent.emit(data);&#125;);]]></content>
      <tags>
        <tag>Angular, AngularJs</tag>
      </tags>
  </entry>
</search>
