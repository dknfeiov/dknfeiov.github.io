<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F17%2Fprerender%E5%8A%A0%E9%80%9F%E7%BD%91%E9%A1%B5%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[使用 prerender（预呈现）加快网页访问速度一、前言如何加速网页访问速度？除了常见的gzip压缩、文件bundle、各级缓存等等，还有没有其他的方式呢？今天了解了一下 Resource Hints，一种浏览器预操作机制，草案定义了 dns-prefetch, preconnect, prefetch, and prerender等多种预操作，在一个页面访问之前，预先做一些工作, 如DNS预解析、HTTP预连接、资源预加载、页面预呈现等，当页面真正加载时，可以更快的呈现出来。 二、核心1. prerender 基本介绍上述多种预操作之中，prerender（预呈现）是其中提升访问速度最明显的，假定我们已经知道用户下一个将要访问的页面地址 http://www.xxx.com.cn，我们通过当前页通过以下方式提前加载页面1&lt;link rel="prerender" href="(http://www.xxx.com.cn)"&gt; 浏览器加载并渲染页面，设置页面状态为预呈现（此时页面不可见），当用户真正访问时，浏览器变更页面的状态为可见，将其迅速呈现出来，页面秒速响应。 注意： 渲染一个页面对浏览器而言是一个昂贵的操作，因为并不是每一次都会去做预处理，包括但不限于以下情况，预处理将被中止。 当资源有限时，防止启动预渲染。 由于高成本或资源需求而放弃预渲染 - 例如高CPU或内存使用，昂贵的数据访问等等。 由于所获取内容的类型或属性而放弃预渲染： 如果目标表现出非幂等行为：共享本地存储的突变，带有除GET，HEAD或OPTION之外的动词的XMLHttpRequest，依此类推。 如果目标触发需要用户输入的条件：确认对话框，身份验证提示，警报等。 2. prerender 兼容性因为还处于工作草案状态，各浏览器对草案支持不一，prerender 目前只有Chrome支持的比较好，具体见下图: 3. prerender 实例因为 prerender 涉及到 页面可见状态 的变更, 当页面处于预加载状态时，document.visibilityState（全局只读属性） 取值是 ‘prerender’, 当页面真正呈现时，值变更为 ‘visible’, 当预加载的时候，我们希望加载静态资源，但不希望在此时去执行一些业务代码、因为浏览器在预加载状态会对一些操作进行限制，比如不允许变更存储状态（localStorage）等，因此，最好的方式是将业务代码延迟到页面呈现时再执行。 以我现在正在做的一个Vue项目为例： 首先，新建一个 test.html 页面，一个单独的测试网页，用于发起prerender12&lt;!-- src 需要是完整的URL地址（包括http://） --&gt;&lt;link rel="prerender" href="http://10.18.200.239:7100"&gt; 以下是原始业务代码入口，现在我们要对它进行修改123456// main.js Vue 项目js入口new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount('#app'); 监听 visibilitychange 事件，当页面可见状态由 prerender 变更为 visible 时，再对进行业务代码初始化。1234567891011121314151617181920212223242526// main.js Vue 项目js入口// 业务代码初始化function init() &#123; new Vue(&#123; router, store, render: h =&gt; h(App) &#125;).$mount('#app');&#125;function visibleChange() &#123; // 页面状态从 prerender 变更为 visible ，再进行业务代码初始化 if (document.visibilityState === 'visible') &#123; init(); document.removeEventListener('visibilitychange', visibleChange); &#125;&#125;// 监听页面状态变更if (document.visibilityState === 'prerender') &#123; document.addEventListener('visibilitychange', visibleChange);&#125; else &#123; // 不经过prerender ,普通方式加载 init();&#125; 因为启动的是本地nginx服务，服务器文件就在本机，响应速度很快，不管是否进行预处理，页面响应速度变化不明显，所以我将Chrome网络限制为 Fast 3G，以下是对照实验： 方案1：清除浏览器缓存，打开浏览器Tab页, 调整网速， 直接在浏览器访问本地项目 http://10.18.200.239:7100 , 页面加载耗时约10s 方案2：清除浏览器缓存，请求测试页 http://localhost:8080/test.html , 发起prerender请求, 打开新Tab页, 调整网速，输入项目地址 http://10.18.200.239:7100 ，页面加载耗时约2s, 从下图中可以看到，js、css等资源都是从缓存中加载（from disk cache）, 速度从10s 到 2s , 也就是说，我们给用户初次访问速度带来 400% 提升，但注意，实际情况可能达不到，还是看具体情况而定。 4. prerender 新变化如果想要知道 prerender 请求是否成功，可以在 chrome://net-internals/#prerender 查看 上图可以看到 Prerender History 表格，记录了发起的prerender请求列表 Origin: Link Rel Prerender (same domain) 标识这个请求是我们发起的，而 Omnibox 标识是由Chrome浏览器自己发起的，Chrome浏览器为了提升页面访问速度，当用户在地址栏输入地址时，有时也会发起prerender URL: 目标url Final Status： 最终状态，常用值有 Timed Out超时、 Duplicate 重复、 Cancelled 取消、 NoStatePrefetch Finished（成功） 自Chrome 63开始，prerender底层的机制发生了变化，表现上也出现了一些差异，但整体来说并不影响使用，底层使用 NoStatePrefetch 取代原有的prerender底层机制, 上面的示例同时在 chrome41 和 chrome47 上进行了测试，都给访问速度带来了额外的提升，以上的写法也是完全兼容的，具体详情见下方参考 参考Introducing NoState PrefetchResource Hints详解HTML5中rel属性的prefetch预加载功能使用Document​.visibility​State]]></content>
  </entry>
  <entry>
    <title><![CDATA[数字产品设计-[笔记-1]]]></title>
    <url>%2F2019%2F04%2F13%2F%5B%E6%95%B0%E5%AD%97%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1%5D-%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[一. 数字产品设计 理解用户的期望、需求、动机和使用情境。 理解商业、技术以及行业的机会、需求和制约。 以上述知识为规划基础来创造产品，让产品的形式、内容、行为可用、 易用，令人满意，无论经济还是技术上均切实可行。 二. 数字产品难用的表现与原因 表现 不尊重用户，频繁的错误消息，责怪用户操作失败，提醒用户操作失败 要求用户像计算机一样思考，预设用户很了解技术、了解很多概念和技术名词 产品未经深刻思考，用户容易误触发，整个产品主线不明确 要求用户做大量的工作 原因 设计流程缺失：没有对客户需求进行收集、分析和利用，产品的终端体验不佳。 无视产品的真实用户：不了解哪些用户的基本需求能推动产品成功。 利益冲突：开发团队既要设计技术体系又要打造用户体验时存在利益冲突。 三. 模型用户界面应该基于用户心理模型，而不是实现模型。 实现模型、心理模型与呈现模型的对比。 工程师往往必须按照既定的方式开发软件，受制于技术和业务上的限制。软件如何工作的模型称作“实现模型”。 用户认为必须用什么方式完成工作以及应用程序如何帮助用户完成工作的 方式被称作用户与软件交互的心理模型。这种模型基于用户自己对如何完成工作和计算机工作原理的理解。 设计师将软件运行机制呈现给用户的方式称为“呈现模型”。 不同于其他两个模型，设计师对呈现模型有更大的控制权。设计者的一个重要目标应当是努力让呈现模型尽可能地匹配用户的心理模型。因此，设计师详细理解目标用户对软件使用方法的看法非常关键。 呈现模型越趋近于用户的心理模型，用户就会感觉程序越容易使用和理解。通常，呈现模 型越趋近实现模型，用户对应用软件的学习和使用能力就越低。这是因为用户的心理模型往往 与软件的实现模型存在差异。我们倾向于采用比实际更简单的心理模型。因此，如果创造的呈现模型比实现模型更为 简单，就能帮助用户更好地理解。]]></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器内部工作原理【摘抄概述】]]></title>
    <url>%2F2019%2F03%2F12%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[从输入一个网址 google.com 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么一、前置信息浏览器主要组件 用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。 浏览器引擎 - 在用户界面和呈现引擎之间传送指令。 渲染引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器。用于解析和执行 JavaScript 代码。 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。 和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个渲染引擎实例。每个标签页都是一个独立的进程 渲染引擎Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。（新版Chrome使用Blink） 二、浏览器渲染HTML 解析HTML Parse 同时包含 词法分析器和语法分析器。 词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词. 语法分析是应用语言的语法规则的过程 输出，解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。 它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。 解析树的根节点是“Document”对象。 CSS解析器解析器都会将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。 处理脚本和样式表的顺序 脚本网络的模型是同步的。网页作者希望解析器遇到&lt;script&gt;标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。 预解析WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。 样式表另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。 渲染树 渲染树。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。 Firefox 将渲染树中的元素称为 “Frame”。WebKit 使用的术语是渲染器或渲染对象。 渲染对象知道如何布局并将自身及其子元素绘制出来 每一个渲染对象都代表了一个矩形的区域，通常对应于相关节点的 CSS 框，这一点在 CSS2 规范中有所描述。它包含诸如宽度、高度和位置等几何信息。 框的类型会受到与节点相关的“display”样式属性的影响 渲染树和 DOM 树的关系 渲染对象是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入渲染树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在渲染树中（但是 visibility 属性值为“hidden”的元素仍会显示）。 有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select”元素有 3 个渲染对象：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的渲染对象而添加 样式计算 存在的难点 样式数据是一个超大的结构，存储了无数的样式属性，这可能造成内存问题。 如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。 应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次） 处理的一些方案 WebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系。并且满足一些其他条件 这些元素必须处于相同的鼠标状态（例如，不允许其中一个是“:hover”状态，而另一个不是） 任何元素都没有 ID 类属性应匹配 元素中不能有任何 inline 样式属性 等等… 不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。(注意这点，有待实践) Firefox 规则树 … 布局 渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。 HTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历 (3.5)。 坐标系是相对于根框架而建立的，使用的是上坐标和左坐标。 布局是一个递归的过程。它从根渲染对象（对应于 HTML 文档的 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的渲染对象计算几何信息。 根渲染对象的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。 所有的渲染对象都有一个“layout”或者“reflow”方法，每一个渲染对象都会调用其需要进行布局的子代的 layout 方法。 渲染 在绘制阶段，系统会遍历渲染树，并调用渲染对象的“paint”方法，将渲染对象的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。 全局绘制和增量绘制和布局一样，绘制也分为全局（绘制整个渲染树）和增量两种。在增量绘制中，部分渲染对象发生了更改，但是不会影响整个树。更改后的渲染对象将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的渲染对象不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历渲染树，直到找到相关的渲染对象，该渲染器会重新绘制自己（通常也包括其子代）。 原文链接]]></content>
  </entry>
  <entry>
    <title><![CDATA[Node log4j模块记录日志]]></title>
    <url>%2F2018%2F12%2F21%2FNode%E6%97%A5%E5%BF%97log4j%2F</url>
    <content type="text"><![CDATA[一.配置 常规配置, 封装logger方法，logger()调用后打印到控制台，并输出日志到文件 12345678910111213141516171819202122232425262728const log4js = require('log4js');log4js.configure(&#123; // 定义 appender appenders: &#123; // 打印到控制台 console: &#123; type: 'console' &#125;, // 输出日志到文件 record: &#123; type: 'file', filename: process.cwd() + '/logs/out.log', maxLogSize: '2M' &#125;, &#125;, categories: &#123; console: &#123; appenders: ['console'], level: 'debug' &#125;, record: &#123; appenders: ['record'], level: 'debug' &#125;, // default 必须有 default: &#123; appenders: ['console'], level: 'debug' &#125; &#125;, // 将普通 console 输出替换成 log4j info 格式 replaceConsole: true&#125;);const recordLog = log4js.getLogger('record');const consoleLog = log4js.getLogger('console');module.exports = function logger(funcName, msg) &#123; recordLog[funcName](msg) consoleLog[funcName](msg)&#125; 二.使用示例1234567891011const logger = require('./utils/logger')// 全局异常记录process.prependListener('uncaughtException', (err) =&gt; &#123; logger('error', `捕获到异常：$&#123;err.stack&#125;\n`)&#125;);process.prependListener('unhandledRejection', (reason, p) =&gt; &#123; logger('error', `未处理的 rejection：$&#123;err.stack&#125;\n`)&#125;); 三. 其他[参考1](https://angular.cn/guide/ajs-quick-reference) [库github链接](https://github.com/log4js-node/log4js-node)]]></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成WebWorker]]></title>
    <url>%2F2018%2F12%2F21%2FVue.js%E9%9B%86%E6%88%90WebWorker%2F</url>
    <content type="text"><![CDATA[一. WebWorker简单介绍 Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以发送XMLHttpRequest请求，可以执行任务而不干扰用户界面。可以通过指定的方式与创建它的JavaScript代码进行交互 在worker内，不能直接操作DOM节点，也不能使用window对象的默认方法和属性。但可以通过self全局属性去使用WebSocket、IndexedDB等功能 workers和主线程间的数据传递都通过postMessage()实现，使用onmessage事件处理函数来响应消息（消息被包含在Message事件的data属性中）。这个过程中数据并不是被共享而是被复制。 二. 配置vue.config.js （vue 配置文件）123456789101112// 配置worker-loader, 处理webworker资源chainWebpack: config =&gt; &#123; config.module .rule('webworker') .test(/\.worker\.js$/) .use('worker-loader') .loader('worker-loader') .end()&#125;parallel: false 注意1： parallel需要设置为false，不然 build 的时候 loader 会报错，大概原因是多线程之间实例共享出现了问题，详情见 https://github.com/vuejs/vue-cli/issues/2785 注意2： 通过配置文件的方式，生产环境存在找不到worker文件的问题 更简单的方式是直接通过 inline 方式，不需要配置webpack，也可以避免上面的问题 12import PreviewWorker from "worker-loader!../../workers/preview.worker.js"; preview.worker.js （worker）123456// 事件处理 self.addEventListener('message', function (e) &#123; const &#123; data &#125; = e; console.log('接收到主线程信息', e) postMessage('worker反馈信息到主线程') &#125;, false); main.js (主线程)123456789101112131415161718import PreviewWorker from "../../workers/preview.worker.js";const worker = new PreviewWorker();worker.postMessage(&#123; a: 1 &#125;);worker.addEventListener("message", function(event) &#123; console.log("接收到worker信息", event);&#125;);// 错误处理worker.addEventListener("error", event =&gt; &#123; console.log("worker 错误", &#123; message: event.message, filename: event.stack, lineno: event.lineno, colno: event.colno &#125;);&#125;); 三.问题解决 不断发送 websocket 请求, Frame内容是 webpackClose , 禁用热更新，问题仍存在, 详情见 https://github.com/webpack/webpack-dev-server/issues/1604 解决方案: 禁止host检测 1234devServer: &#123; disableHostCheck: true&#125; 加载worker文件，返回的是主页index.html, 定位问题原因是无法检测到worker文件修改，没有生成 .worker.js 文件 解决方案： 直接通过 inline 方式加载 12import PreviewWorker from "worker-loader!../../workers/preview.worker.js"; 四.其他相关 记得及时销毁worker，避免内存泄漏 12345678beforeDestroy() &#123; // worker 回收 if (this.worker) &#123; this.worker.terminate(); console.warn("WORKRT DESTROYED!"); &#125;&#125; workerize-loader 也是一个处理webwoker资源的加载器，提供另一种加载方式 worker 与 主线程之间传输大文件时，可以采用 Transferable Objects 提升传输性能，但存在一些限制, 详情见Transferable Objects: Lightning Fast!]]></content>
      <tags>
        <tag>Vue, WebWorker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx缓存302请求导致重定向循环]]></title>
    <url>%2F2018%2F10%2F06%2Fnginx%E7%BC%93%E5%AD%98302%E8%AF%B7%E6%B1%82%E5%AF%BC%E8%87%B4%E9%87%8D%E5%AE%9A%E5%90%91%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[一.概述 前端遗留项目，将其嵌入新开发的门户网站中，作为子项目，嵌入之后发现访问速度很慢，平均加载耗时超过10s，性能分析之后，发现存在以下的问题： 需要加载的静态资源多，差不多120多个，且大部分没有经过压缩 原系统部署在内网，门户网站部署在阿里云，嵌入之后访问速度受到内外网带宽的影响，且访问相当于多了一次跳转 每次ajax请求需要去sso（统一登录平台）校验是否登录，对性能也有一定的影响 二.详细1. 通过nginx配置加速网页访问系统访问流程图如下： 因为遗留项目为第三方系统，只提供了压缩包，无法修改项目源码，那就只能在nginx服务器和浏览器端进行优化 采取措施如下： 开启gzip压缩文件大小，浏览器静态资源缓存，开启nginx代理缓存 nginx部分配置:1234567891011121314151617181920212223242526272829303132333435http &#123; # gzip压缩 gzip on; gzip_min_length 5k; gzip_buffers 4 16k; gzip_comp_level 3; gzip_types text/plain application/javascript text/css application/xml text/javascript image/jpeg image/gif image/png; gzip_vary on; # proxy 缓存空间 声明 proxy_cache_path proxy_cache_static levels=1:2 keys_zone=cache_static:20m; # 请求头 判断缓存是否命中 add_header Nginx-Cache $upstream_cache_status; server &#123; listen 8080; server_name 127.0.0.1; # 遗留项目 proxy 缓存 location /url &#123; # 浏览器静态资源缓存 expires 7d; proxy_cache cache_static; # 缓存7天 proxy_cache_valid 200 206 304 301 302 7d; # 缓存唯一KEY值 proxy_cache_key $uri; proxy_pass http://10.18.194.161:7001; &#125; &#125;&#125; 经过如上配置，页面访问速度得到极大提升，访问速度控制在1s以内 2. 重定向循环问题出现解决了访问速度的问题，不久业务部门又反馈了一个问题，登陆之后，隔段时间再操作，页面有时会一直闪烁，无法正常操作，经过chrome调试，发现是因为发生了302重定向循环，开始分析问题 正常访问，命中nginx缓存（HIT），返回200： 重定向循环异常，返回302： 查看异常详情，发现nginx缓存仍然命中（HIT），且返回302重定向到当前资源： 3. 问题发现及解决我们从结果倒推，首先，查看请求头，请求头中的 Nginx-Cache 返回 HIT ,由此可知，我们的错误响应是由nignx返回的，而没有到达遗留项目，既然错误响应是由nginx缓存返回的，查看nginx缓存配置，发现我们的配置确实存在缓存302请求的可能1proxy_cache_valid 200 206 304 301 302 7d; 然后，就是要找到它是什么时候缓存了这个302重定向了，与后台同学一起，从前到后分析了请求的整个流程，最终定位问题出现在sso登录校验阶段，用户一段时间未操作，登录状态过期，导致静态资源请求触发302，并复现了问题 首先，清空浏览器登陆信息，不访问登陆页面，而是先直接访问静态资源common.js，后台拦截请求，判断当前未登陆，跳转到sso单点登陆页面，登陆成功，sso重定向到之前访问的路径，也就是如下图 而我们之前的问题也就很清楚了，浏览器请求静态资源common.js，请求经过nginx，到达遗留项目，遗留项目判断当前未登陆，跳转到sso登陆，登陆成功后返回302重定向到登陆之前的路径也就是common.js资源路径，返回又经nginx，nginx缓存了这个302返回，并将该响应返回到浏览器，浏览器根据302状态码，再次发起对common.js的请求，nginx直接返回302，重定向循环就这么理所当然的发生了 问题的分析，溯源花了很长的时候，解决问题只需稍微修改nginx配置即可，如下，去掉对302请求的缓存即可 12345#beforeproxy_cache_valid 200 206 304 301 302 7d;#afterproxy_cache_valid 200 206 304 301 7d;]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能监控]]></title>
    <url>%2F2018%2F09%2F19%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[一.概述 门户入口，通过iframe集成其他内部项目，希望当用户打开项目(不管是门户或者iframe页)时，上报指标如当前时间、访问Url、项目、页面加载耗时、超时资源等 主要目的是： 希望实现网络故障或繁忙时，自动预警 有针对性的优化用户访问速度，找到用户访问慢的根源 根据用户上报信息，对访问时段、访问频次、项目打开频次等数据做进一步的探索 二.大致步骤1. 通过PerFormance对象获取性能信息通过perFormance全局对象可以获取页面性能相关信息，目前兼容到IE10，已经可用 获取页面加载时间123performance.getEntriesByType('navigation')通过name获取加载当前url , 根据domComplete获取页面加载耗（ms） 获取超时资源列表12345performance.getEntriesByType('resource') .filter(item =&gt; item.duration &gt;= 5000) // 找出加载时间超过5s 的资源// initiatorType 类型// name 名称// duration 耗时 2. 页面加载完自动上报1234567891011121314reportNavigate() &#123; // 后台上报&#125;// 简略实现window.onload = function (e) &#123; // 尽量不影响页面主线程 if (this.$window.requestIdleCallback) &#123; this.$window.requestIdleCallback(this.reportNavigate) &#125; else &#123; setTimeout(this.reportNavigate) &#125;&#125; 3. 监控iframe加载通过传入iframe的window全局对象 三.完整代码1234567// 监控主项目，自动上报new PerformanceMonitor('main')// 监控iframe子项目， 手动上报this.monitor = new PerformanceMonitor('iframe', window.frames[0].window, null, false)// jsx&lt;iframe onLoad=&#123;() =&gt; &#123;this.monitor.reportNavigate()&#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// 定义监控类import &#123; report &#125; from '../services/monitor'import moment from 'moment'export default class PerformanceMonitor &#123; SECOND = 1000 /** * origin 标示来源，当有多个日志源时 * $window 默认为window对象，iframe传入iframe的全局window对象 * timeout 超时时间判断 * auto 默认自动上报，若为false，需手动调用上报方法 */ constructor(origin, $window, timeout, auto = true) &#123; this.origin = origin this.timeout = timeout || this.SECOND * 5 this.$window = $window || window this.reportNavigate = this.reportNavigate.bind(this) // 自动上报 if (auto) &#123; this.bindNavigate() &#125; &#125; // 获取页面加载时间 getLoadTime() &#123; const navigation = this.$window.performance.getEntriesByType('navigation') if (navigation &amp;&amp; navigation.length !== 0) &#123; return navigation[0].domComplete &#125; else &#123; // 兼容低版本Chrome return this.$window.performance.timing.domComplete - this.$window.performance.timing.navigationStart &#125; &#125; // 获取超时资源 getTimeoutRes() &#123; // initiatorType 类型 // name 名称 // duration 耗时 const resourceTimes = this.$window.performance.getEntriesByType('resource') return resourceTimes .filter(item =&gt; item.duration &gt;= this.timeout) .map(res =&gt; (&#123; TIMEOUTRES_TYPE: res.initiatorType || 'null', TIMEOUTRES_URL: res.name, TIMEOUTRES_DATE: res.duration &#125;)) &#125; // 获取当前URl并解码 getUrl() &#123; let url try &#123; url = decodeURIComponent(this.$window.location.href) &#125; catch (error) &#123; console.log('url decode异常') url = this.$window.location.href &#125; return url &#125; // 页面加载完上报 reportNavigate() &#123; const domComplete = this.getLoadTime() const timeoutRes = this.getTimeoutRes() const url = this.getUrl() const logData = &#123; MONITOR_ORIGIN: this.origin, MONITOR_TYPE: 'navigate', MONITOR_URL: url, MONITOR_TIMEOUT: this.timeout, MONITOR_TIMEOUTRES: timeoutRes, MONITOR_LOADTIME: domComplete, MONITOR_REPORTTIME: moment().format('YYYY-MM-DD HH:mm:ss') &#125; this.report(logData) &#125; // 可以自定义上报信息 report(data) &#123; try &#123; report(data) &#125; catch (error) &#123; console.log('日志上报异常', error) &#125; &#125; // 绑定事件、自动上报 bindNavigate() &#123; const oldOnload = this.$window.onload this.$window.onload = function (e) &#123; if (oldOnload &amp;&amp; typeof oldOnload === 'function') &#123; oldOnload(e) &#125; // 尽量不影响页面主线程 if (this.$window.requestIdleCallback) &#123; this.$window.requestIdleCallback(this.reportNavigate) &#125; else &#123; setTimeout(this.reportNavigate) &#125; &#125;.bind(this) &#125;&#125;]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DvaJS model复用的方案]]></title>
    <url>%2F2018%2F08%2F30%2FDvaJS%E5%AE%9E%E7%8E%B0model%E5%A4%8D%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Dva 下 model 复用 （一个model同时对应多个业务模块，业务模块间数据互不影响）前置知识: dva =&gt; 一个基于 redux 和 redux-saga 的数据流方案 react =&gt; 高阶组件的定义 1. 示例描述：多Tab结构， 存在A、B、C 业务模块，数据不同，业务逻辑一致，希望实现代码复用 2. 示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// router.js // 1. 动态加载 model 和 路由组件&#123; path: 'product', getComponent(nextState, cb) &#123; require.ensure([], require =&gt; &#123; // 从location 中获取业务类型 type const type = nextState.location.query.type // 加载model并挂载到dva实例上 注意：require后接了()，因为返回的是一个函数，函数执行返回真正将被挂载的model对象 app.model(require('./models/product')(type)) // 加载路由组件 require 返回的也是一个函数，函数执行返回一个React组件（高阶组件，在真正的路由组件上包了一层） cb(null, require('./routes/product')(type)) &#125;, 'product') &#125;&#125;// models/product.js // 2. 根据type 动态生成 modelexport default function modelGenerate(type) &#123; return &#123; namespace: `products$&#123;type&#125;`, state: &#123; list: [] &#125;, reducers: &#123; &#125; effects: &#123; &#125; &#125;&#125;;// routes/product.jsx // 3. 根据type 动态返回 新的React组件（对业务组件进行包装）export default function routeGenarate(type) &#123; // 根据type找到命名空间 const namespace = `products$&#123;type&#125;` function ProductWrapper() &#123; return class extends React.Component &#123; render() &#123; return &lt;Products &#123;...this.props&#125; /&gt; &#125; &#125; &#125; // 根据 namespace(命名空间) 从redux store 获取对应的model实例数据 ，并命名为 productModel return connect(store =&gt; (&#123; productModel: store[namespace] &#125;))(ProductWrapper())&#125;// 业务组件 从 props.productModel 获取数据const Products = (&#123; dispatch, productModel &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;ProductList list=&#123;productModel.list&#125; /&gt; &lt;/div&gt; );&#125;]]></content>
      <tags>
        <tag>React, DvaJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator与async、await[借鉴自MDN]]]></title>
    <url>%2F2018%2F08%2F30%2FGenerator%E4%B8%8Easync%2Cawait%2F</url>
    <content type="text"><![CDATA[一. ES6 Generator(生成器) 语法function* 用于定义一个生成器函数（generator function），它返回一个Generator对象, Generator对象被创建后，通过调用next()方法获取值 yield 关键字用来暂停和恢复一个生成器函数 语法： yield关键字使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个基于生成器的版本的return关键字 yield关键字实际返回一个IteratorResult对象，它有两个属性，value和done。value属性是对yield表达式求值的结果，而done是false，表示生成器函数尚未完全完成。 一旦遇到 yield 表达式，生成器的代码将被暂停运行，直到生成器的 next() 方法被调用。每次调用生成器的next()方法时，生成器都会恢复执行，直到达到以下某个值: yield，导致生成器再次暂停并返回生成器的新值。 下一次调用next()时，在yield之后紧接着的语句继续执行。 throw用于从生成器中抛出异常。这让生成器完全停止执行，并在调用者中继续执行，正如通常情况下抛出异常一样。 到达生成器函数的结尾；在这种情况下，生成器的执行结束，并且IteratorResult给调用者返回undefined并且done为true。 到达return 语句。在这种情况下，生成器的执行结束，并将IteratorResult返回给调用者，其值是由return语句指定的，并且done 为true。 示例 1234567891011function* countAppleSales () &#123; var saleList = [3, 7, 5]; for (var i = 0; i &lt; saleList.length; i++) &#123; yield saleList[i]; &#125;&#125;var appleStore = countAppleSales(); // Generator &#123; &#125;console.log(appleStore.next()); // &#123; value: 3, done: false &#125;console.log(appleStore.next()); // &#123; value: 7, done: false &#125;console.log(appleStore.next()); // &#123; value: 5, done: false &#125;console.log(appleStore.next()); // &#123; value: undefined, done: true &#125; 注意： 不能在forEach等方法中直接使用yield，因为forEach等接受一个函数作为参数，yield外层执行环境不是生成器函数，所以会报语法错误，错误示例如下 12345function* nameGenerator() &#123; ['Hellon','Nancy'].forEach(item =&gt; &#123; yield item // =&gt; Uncaught SyntaxError: Unexpected identifier &#125;)&#125; 也可作为对象属性存在，通过如下方式定义 1*countAppleSales() &#123;&#125; yield* 表达式用于委托给另一个generator 或可迭代对象。 二. Async function： async function 声明将定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。但是如果你的代码使用了异步函数，它的语法和结构会更像是标准的同步函数 1). 当调用一个 async 函数时，会返回一个 Promise 对象。当这个 async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值；当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。 2). async 函数中可能会有 await 表达式，这会使 async 函数暂停执行，等待表达式中的 Promise 解析完成后继续执行 async 函数并返回解决结果 await 操作符用于等待一个Promise 对象。它只能在异步函数 async function 中使用 1). await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行 async function。 2). 若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。 3). 另外，如果 await 操作符后的表达式的值不是一个 Promise，那么该值将被转换为一个已正常处理的 Promise。 三. Generator 结合 async/await1234567891011121314151617181920212223242526// 模拟发起请求，获取数据function getData() &#123; return new Promise((resolve) =&gt; &#123; data = `MOCK DATA $&#123;new Date()&#125;` setTimeout(_ =&gt; &#123; resolve(data) &#125;, 2000) &#125;)&#125;// 迭代器，调用next()请求最新数据async function* timerGenerator () &#123; while (true) &#123; yield getData() &#125;&#125;// 业务代码，获取最新数据async function execute() &#123; const timer = timerGenerator() console.log(await timer.next()) // &#123;value: "MOCK DATA Thu Aug 30 2018 10:57:51 GMT+0800 (中国标准时间)", done: false&#125; console.log(await timer.next()) // &#123;value: "MOCK DATA Thu Aug 30 2018 10:57:53 GMT+0800 (中国标准时间)", done: false&#125; console.log(await timer.next()) // &#123;value: "MOCK DATA Thu Aug 30 2018 10:57:55 GMT+0800 (中国标准时间)", done: false&#125; console.log(await timer.next()) // &#123;value: "MOCK DATA Thu Aug 30 2018 10:57:57 GMT+0800 (中国标准时间)", done: false&#125;&#125;execute()]]></content>
      <tags>
        <tag>javascript 、es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular-React比较]]></title>
    <url>%2F2018%2F05%2F26%2FAngular-React%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[概述我对前端框架的看法是，同一个问题的多种解决方案，每个方案都有各有适应的场景和人群，但既然解决的是同一个问题，殊途同归，本文就是根据自己的使用经验，列举出Angular、React二者在不同中的相通之处 示例代码皆为伪代码，仅供理解 脉络 前端现代框架的一些基本逻辑: 组件化, 从原来代码级的复用提升到组件层，组件抽象出可复用的功能与UI，就像一个个零件 数据驱动，隐藏DOM操作的细节，页面工程化，整个页面就是一个大的机器，组件就是组成机器一个个的齿轮，受内外部数据驱动，影响周围的齿轮随之发生变化 工程化，集成脚手架等插件，使用路由统一入口 细节一. Angular 关键词： 模块化、组件化、依赖注入、脏检查 Angular应用是模块化的，一个NgModule（模块）就是一个容器，存放一些内聚代码块，如组件、指令、服务、管道等，提供导入、导出功能，每个Angular应用都会有一个根模块，引导根模块启动项目 组件可以通过路由器加载，也可以通过模板创建，组件是指令的一种，是带模版的指令，除了组件外，指令还有结构型指令和功能型指令二种，指令拥有生命周期钩子函数。在生命周期不同阶段被调用 依赖注入机制，注入器是树形结构，注入的服务是单例，子模块中定义的provider将被注册到根注入器，除非子模块为懒加载，懒加载模块单独生成一个注入器，除此之外，组件也拥有组件级注入器 Angular脏检查由ngZone触发，zone重写了一系列异步方法，如事件、定时器、封装了ajax请求，添加了回调钩子函数，在回调中进行数据变更检查，为组件设置onPush策略，组件将只在Input数据发生变化时触发检查，组件可注入changeDetection手动设置脏检查机制 其他，路由、HttpCLient + 拦截器机制， 视图封装模式（Native、Emulated、None），动态组件、dom操作（Renderer）、Rxjs管理异步事件流 二. React 关键词： 组件化、函数式编程、虚拟dom React 维护一颗组件树， 数据通过props从上往下单向流动，组件内部通过state保存状态，通过setState改变state的值，默认当props或state发生变化，组件重新渲染，PureReactComponent组件默认判断新旧props,state（浅引用判断）值，如果没有变化，不重新渲染，但过多diff操作同样消耗性能， 普通Component 可通过使用 shouldComponentUpdate生命周期钩子，返回true|false 来决定是否重新渲染组件，结合 immutable 对象可以更好的对性能进行优化 React 组件有3种创建方式（函数式、ES6、ES5），函数式无状态组件拥有更好的性能,每次重新渲染相当于重新执行一次函数,但如果需要用到state 、组件生命周期，则需要使用ES6方式, 通过ES5语法创建现已不推荐使用, jsx-函数式编程，可以用js来构建视图，可以使用临时变量、自带的流程控制、js当前作用域等，相比较于Angular的模板（Template）更为灵活 react利用key来识别组件，它是一种身份标识标识，当key发生变化，销毁原有组件，创建新组件，key没有变化，数据变化，重新渲染原组件 二者比较 数据流向： Angular 数据从上往下，单向流动，通过Output自定义事件与父组件通信 ， React 通过props从上往下，数据单向流动，通过state保存当前组件内部的状态，通过setState改变组件内部状态，与父组件通信通常通过状态提升来完成，常结合redux/mobx使用 不可变性：因为数据单向流动，所有子组件从父级接收的数据是不可变的（@Input 、props），Angular如果要对@Input传递的数据进行处理，可以用set去实现 Angular使用模板语法，通过结构型指令如ngIf、ngFor 实现条件渲染、列表展示, React通过jsx语法实现同样的功能，如下 1var &amp;&amp; &lt;div&gt;、datas.map(i,v) Angular 表单提供二种方式，模板驱动与响应式表单，前者通过模板语法与指令实现，后者由模型驱动，预先定义字段、校验项、初始值，提供校验方法，React 表单一般通过受控组件的方式实现 React 组件的props.children 类似于 Angular 的内容映射(通过ng-content指令实现) 避免重复渲染，性能优化，React 通常使用 shouldComponentUpdate + Immutable 对象减少重复渲染， Angular通常设置 changedetectionstrategy.onpush + Immutable 对象 集成第三方库时，常需要获取Dom对象，React使用 refs传递，Angular 通过ViewChild实现对dom节点的引用 12345678React : &lt;div ref=&#123;domRef&#125;&gt; // 通过this.domRef获取dom节点Angular : .ts: ViewChild(selector) domRef .html: &lt;div seletor&gt; Angular 相对React ，概念更多，给出了一个更复杂的解决方案，但同时，Angular提供了React没有的模块化、提供成体系的前端技术解决方案、引入typescript进行类型定义，对于大型协作项目的团队式开发和长期维护，是一个不错的选择，但正因为想要做的事情太多，不得不引入大量抽象概念，前期需要花费更多的时间 React 虽只提供了简单的API，但结合JSX语法，非常灵活且强大，但是灵活意味着容易犯错，相比较Angular，更容易把代码写的难以维护，对开发者个人的能力要求更高]]></content>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular实现元素双击可编辑]]></title>
    <url>%2F2018%2F02%2F28%2FAngular%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E5%8F%8C%E5%87%BB%E5%8F%AF%E7%BC%96%E8%BE%91%2F</url>
    <content type="text"><![CDATA[一.概述如果希望实现一个DOM元素，双击可编辑，失去焦点不可编辑，常用的方式，是绑定dblclick事件，当事件触发，将文本内容替换为表单元素，失去焦点，再替换为文本，这种做法固然简单，但如果要操作的dom元素太多，既要添加表单元素，还要监听dblclick、blur事件，代码不可避免会变得非常繁琐 所以我采取的做法是，抽象出一个指令，将指令注册为表单控件，实现双向绑定，结合DOM的contentEditable属性，只要在DOM元素上添加该指令即可具备该能力 使用1&lt;div appCanEdit [(ngModel)]="item.value"&gt;&lt;/div&gt; 效果 二.实现步骤1. 创建指令，实现 ControlValueAccessor接口 ControlValueAccessor是一个连接表单模型和视图（DOM元素）的接口，自定义的表单控件必须实现这个接口,它的作用是把 form 模型中值映射到视图中，当视图发生变化时，通知 form directives 或 form controls 12345678910111213141516171819202122232425@Directive(&#123; selector: '[appCanEdit]'&#125;)export class ElementCanEditDirective implements ControlValueAccessor &#123; _value; // callback function propagateChange = (value: any) =&gt; &#123; &#125;; // Writes a new value to the element ，temporarily store the value in '_value' writeValue(value: any) &#123; if (value) &#123; this._value = value; &#125; &#125; // when the control's value changes in the UI, call the callback function registerOnChange(fn: any) &#123; this.propagateChange = fn; &#125; registerOnTouched(fn: any) &#123; &#125; constructor( ) &#123; &#125;&#125; 2. 注册成为表单控件，将控件本身注册到DI框架成为一个可以让表单访问其值的控件12345678910@Directive(&#123; selector: '[appCanEdit]', providers: [ &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; ElementCanEditDirective), multi: true &#125; ],&#125;) 3. 通过@HostListener 为组件添加事件绑定，通过@HostBinding实现元素innerText随value而变化 当元素处于可编辑状态时，添加content-editable类样式，以便灵活控制样式 123456789101112131415161718192021@HostBinding() get innerText() &#123; return this._value;&#125;@HostListener('blur', ['$event.target'])onBlur(ele: HTMLElement) &#123; ele.contentEditable = 'false'; this._value = ele.innerText; this.propagateChange(this._value); this.render.removeClass(ele, 'content-editable');&#125;@HostListener('dblclick', ['$event.target'])dbClick(ele: HTMLElement) &#123; // plaintext-only ele.contentEditable = 'true'; ele.innerText = ele.innerText; ele.focus(); this.render.addClass(ele, 'content-editable');&#125; 三.完整代码1&lt;div appCanEdit [(ngModel)]="item.value"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import &#123; Component, OnInit, Input, EventEmitter, Directive, HostListener, HostBinding, Renderer2, forwardRef &#125; from '@angular/core';import &#123; ControlValueAccessor, NG_VALUE_ACCESSOR &#125; from '@angular/forms';/** * 让DOM元素可编辑 * 可在元素上使用 ngModel * @export * @class ElementCanEditDirective * @implements &#123;ControlValueAccessor&#125; */@Directive(&#123; selector: '[appCanEdit]', providers: [ &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; ElementCanEditDirective), multi: true &#125; ],&#125;)export class ElementCanEditDirective implements ControlValueAccessor &#123; _value; // callback function propagateChange = (value: any) =&gt; &#123; &#125;; // Writes a new value to the element ，temporarily store the value in '_value' writeValue(value: any) &#123; if (value) &#123; this._value = value; &#125; &#125; // when the control's value changes in the UI, call the callback function registerOnChange(fn: any) &#123; this.propagateChange = fn; &#125; registerOnTouched(fn: any) &#123; &#125; @HostBinding() get innerText() &#123; return this._value; &#125; @HostListener('blur', ['$event.target']) onBlur(ele: HTMLElement) &#123; ele.contentEditable = 'false'; this._value = ele.innerText; this.propagateChange(this._value); this.render.removeClass(ele, 'content-editable'); &#125; @HostListener('dblclick', ['$event.target']) dbClick(ele: HTMLElement) &#123; ele.contentEditable = 'true'; ele.innerText = ele.innerText; ele.focus(); this.render.addClass(ele, 'content-editable'); &#125; constructor( private render: Renderer2 ) &#123; &#125;&#125;]]></content>
      <tags>
        <tag>Angular , React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs到Angular的变化]]></title>
    <url>%2F2017%2F10%2F28%2FAngularJs%E5%88%B0Angular%E7%9A%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[概述关于AngularJs、Angular 一脉相承的思路与不同之处 以下只是个人使用过程中的的一些感受,具体二者之间的差别参考 [官方文档](https://angular.cn/guide/ajs-quick-reference) 细节 引入脚手架，提供Typescript es6超集 , 支持 import export ,不需额外引入模块加载器 将组件和指令二者剥离开来，前者组成页面，后者分为结构性指令和功能性指令, 不再支持replace等 移除controller, $scope等 provider，service,factory 统一为 service, 减少理解上的困惑 angularJs 只有一个注入器，所有服务都是单例，Angular的注入器则是一个树状结构，可以为一个注入对象实现不同的实例（在不同的注入器上） controller &lt;=&gt; component 一定意义上等价，都封装了model实体模型，指定html模板,业务逻辑，也都挂靠在模块上 在setTimeout等异步执行环境中不再需要手动调用$scope.$apply() , angular的代码都运行在 zone中，通过为异步方法打补丁的方式，在方法执行完后自动的执行数据检查，如果使用第三方类库，存在异步操作，想要纳入Angular管理，可以通过以下方式实现 123this.ngZone.run(() =&gt; &#123; this.service.uploadEvent.emit(data);&#125;);]]></content>
      <tags>
        <tag>Angular, AngularJs</tag>
      </tags>
  </entry>
</search>
