<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端性能监控]]></title>
    <url>%2F2018%2F09%2F19%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[一.概述 门户入口，通过iframe集成其他内部项目，希望当用户打开项目(不管是门户或者iframe页)时，上报指标如当前时间、访问Url、项目、页面加载耗时、超时资源等 主要目的是： 希望实现网络故障或繁忙时，自动预警 有针对性的优化用户访问速度，找到用户访问慢的根源 根据用户上报信息，对访问时段、访问频次、项目打开频次等数据做进一步的探索 二.大致步骤1. 通过PerFormance对象获取性能信息通过perFormance全局对象可以获取页面性能相关信息，目前兼容到IE10，已经可用 获取页面加载时间123performance.getEntriesByType('navigation')通过name获取加载当前url , 根据domComplete获取页面加载耗（ms） 获取超时资源列表12345performance.getEntriesByType('resource') .filter(item =&gt; item.duration &gt;= 5000) // 找出加载时间超过5s 的资源// initiatorType 类型// name 名称// duration 耗时 2. 页面加载完自动上报1234567891011121314reportNavigate() &#123; // 后台上报&#125;// 简略实现window.onload = function (e) &#123; // 尽量不影响页面主线程 if (this.$window.requestIdleCallback) &#123; this.$window.requestIdleCallback(this.reportNavigate) &#125; else &#123; setTimeout(this.reportNavigate) &#125;&#125; 3. 监控iframe加载通过传入iframe的window全局对象 三.完整代码1234567// 监控主项目，自动上报new PerformanceMonitor('main')// 监控iframe子项目， 手动上报this.monitor = new PerformanceMonitor('iframe', window.frames[0].window, null, false)// jsx&lt;iframe onLoad=&#123;() =&gt; &#123;this.monitor.reportNavigate()&#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// 定义监控类import &#123; report &#125; from '../services/monitor'import moment from 'moment'export default class PerformanceMonitor &#123; SECOND = 1000 /** * origin 标示来源，当有多个日志源时 * $window 默认为window对象，iframe传入iframe的全局window对象 * timeout 超时时间判断 * auto 默认自动上报，若为false，需手动调用上报方法 */ constructor(origin, $window, timeout, auto = true) &#123; this.origin = origin this.timeout = timeout || this.SECOND * 5 this.$window = $window || window this.reportNavigate = this.reportNavigate.bind(this) // 自动上报 if (auto) &#123; this.bindNavigate() &#125; &#125; // 获取页面加载时间 getLoadTime() &#123; const navigation = this.$window.performance.getEntriesByType('navigation') if (navigation &amp;&amp; navigation.length !== 0) &#123; return navigation[0].domComplete &#125; else &#123; // 兼容低版本Chrome return this.$window.performance.timing.domComplete - this.$window.performance.timing.navigationStart &#125; &#125; // 获取超时资源 getTimeoutRes() &#123; // initiatorType 类型 // name 名称 // duration 耗时 const resourceTimes = this.$window.performance.getEntriesByType('resource') return resourceTimes .filter(item =&gt; item.duration &gt;= this.timeout) .map(res =&gt; (&#123; TIMEOUTRES_TYPE: res.initiatorType || 'null', TIMEOUTRES_URL: res.name, TIMEOUTRES_DATE: res.duration &#125;)) &#125; // 获取当前URl并解码 getUrl() &#123; let url try &#123; url = decodeURIComponent(this.$window.location.href) &#125; catch (error) &#123; console.log('url decode异常') url = this.$window.location.href &#125; return url &#125; // 页面加载完上报 reportNavigate() &#123; const domComplete = this.getLoadTime() const timeoutRes = this.getTimeoutRes() const url = this.getUrl() const logData = &#123; MONITOR_ORIGIN: this.origin, MONITOR_TYPE: 'navigate', MONITOR_URL: url, MONITOR_TIMEOUT: this.timeout, MONITOR_TIMEOUTRES: timeoutRes, MONITOR_LOADTIME: domComplete, MONITOR_REPORTTIME: moment().format('YYYY-MM-DD HH:mm:ss') &#125; this.report(logData) &#125; // 可以自定义上报信息 report(data) &#123; try &#123; report(data) &#125; catch (error) &#123; console.log('日志上报异常', error) &#125; &#125; // 绑定事件、自动上报 bindNavigate() &#123; const oldOnload = this.$window.onload this.$window.onload = function (e) &#123; if (oldOnload &amp;&amp; typeof oldOnload === 'function') &#123; oldOnload(e) &#125; // 尽量不影响页面主线程 if (this.$window.requestIdleCallback) &#123; this.$window.requestIdleCallback(this.reportNavigate) &#125; else &#123; setTimeout(this.reportNavigate) &#125; &#125;.bind(this) &#125;&#125;]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DvaJS model复用的方案]]></title>
    <url>%2F2018%2F08%2F30%2FDvaJS%E5%AE%9E%E7%8E%B0model%E5%A4%8D%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Dva 下 model 复用 （一个model同时对应多个业务模块，业务模块间数据互不影响）前置知识: dva =&gt; 一个基于 redux 和 redux-saga 的数据流方案 react =&gt; 高阶组件的定义 1. 示例描述：多Tab结构， 存在A、B、C 业务模块，数据不同，业务逻辑一致，希望实现代码复用 2. 示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// router.js // 1. 动态加载 model 和 路由组件&#123; path: 'product', getComponent(nextState, cb) &#123; require.ensure([], require =&gt; &#123; // 从location 中获取业务类型 type const type = nextState.location.query.type // 加载model并挂载到dva实例上 注意：require后接了()，因为返回的是一个函数，函数执行返回真正将被挂载的model对象 app.model(require('./models/product')(type)) // 加载路由组件 require 返回的也是一个函数，函数执行返回一个React组件（高阶组件，在真正的路由组件上包了一层） cb(null, require('./routes/product')(type)) &#125;, 'product') &#125;&#125;// models/product.js // 2. 根据type 动态生成 modelexport default function modelGenerate(type) &#123; return &#123; namespace: `products$&#123;type&#125;`, state: &#123; list: [] &#125;, reducers: &#123; &#125; effects: &#123; &#125; &#125;&#125;;// routes/product.jsx // 3. 根据type 动态返回 新的React组件（对业务组件进行包装）export default function routeGenarate(type) &#123; // 根据type找到命名空间 const namespace = `products$&#123;type&#125;` function ProductWrapper() &#123; return class extends React.Component &#123; render() &#123; return &lt;Products &#123;...this.props&#125; /&gt; &#125; &#125; &#125; // 根据 namespace(命名空间) 从redux store 获取对应的model实例数据 ，并命名为 productModel return connect(store =&gt; (&#123; productModel: store[namespace] &#125;))(ProductWrapper())&#125;// 业务组件 从 props.productModel 获取数据const Products = (&#123; dispatch, productModel &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;ProductList list=&#123;productModel.list&#125; /&gt; &lt;/div&gt; );&#125;]]></content>
      <tags>
        <tag>React, DvaJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator与async、await[借鉴自MDN]]]></title>
    <url>%2F2018%2F08%2F30%2FGenerator%E4%B8%8Easync%2Cawait%2F</url>
    <content type="text"><![CDATA[一. ES6 Generator(生成器) 语法function* 用于定义一个生成器函数（generator function），它返回一个Generator对象, Generator对象被创建后，通过调用next()方法获取值 yield 关键字用来暂停和恢复一个生成器函数 语法： yield关键字使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个基于生成器的版本的return关键字 yield关键字实际返回一个IteratorResult对象，它有两个属性，value和done。value属性是对yield表达式求值的结果，而done是false，表示生成器函数尚未完全完成。 一旦遇到 yield 表达式，生成器的代码将被暂停运行，直到生成器的 next() 方法被调用。每次调用生成器的next()方法时，生成器都会恢复执行，直到达到以下某个值: yield，导致生成器再次暂停并返回生成器的新值。 下一次调用next()时，在yield之后紧接着的语句继续执行。 throw用于从生成器中抛出异常。这让生成器完全停止执行，并在调用者中继续执行，正如通常情况下抛出异常一样。 到达生成器函数的结尾；在这种情况下，生成器的执行结束，并且IteratorResult给调用者返回undefined并且done为true。 到达return 语句。在这种情况下，生成器的执行结束，并将IteratorResult返回给调用者，其值是由return语句指定的，并且done 为true。 示例 1234567891011function* countAppleSales () &#123; var saleList = [3, 7, 5]; for (var i = 0; i &lt; saleList.length; i++) &#123; yield saleList[i]; &#125;&#125;var appleStore = countAppleSales(); // Generator &#123; &#125;console.log(appleStore.next()); // &#123; value: 3, done: false &#125;console.log(appleStore.next()); // &#123; value: 7, done: false &#125;console.log(appleStore.next()); // &#123; value: 5, done: false &#125;console.log(appleStore.next()); // &#123; value: undefined, done: true &#125; 注意： 不能在forEach等方法中直接使用yield，因为forEach等接受一个函数作为参数，yield外层执行环境不是生成器函数，所以会报语法错误，错误示例如下 12345function* nameGenerator() &#123; ['Hellon','Nancy'].forEach(item =&gt; &#123; yield item // =&gt; Uncaught SyntaxError: Unexpected identifier &#125;)&#125; 也可作为对象属性存在，通过如下方式定义 1*countAppleSales() &#123;&#125; yield* 表达式用于委托给另一个generator 或可迭代对象。 二. Async function： async function 声明将定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。但是如果你的代码使用了异步函数，它的语法和结构会更像是标准的同步函数 1). 当调用一个 async 函数时，会返回一个 Promise 对象。当这个 async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值；当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。 2). async 函数中可能会有 await 表达式，这会使 async 函数暂停执行，等待表达式中的 Promise 解析完成后继续执行 async 函数并返回解决结果 await 操作符用于等待一个Promise 对象。它只能在异步函数 async function 中使用 1). await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行 async function。 2). 若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。 3). 另外，如果 await 操作符后的表达式的值不是一个 Promise，那么该值将被转换为一个已正常处理的 Promise。 三. Generator 结合 async/await1234567891011121314151617181920212223242526// 模拟发起请求，获取数据function getData() &#123; return new Promise((resolve) =&gt; &#123; data = `MOCK DATA $&#123;new Date()&#125;` setTimeout(_ =&gt; &#123; resolve(data) &#125;, 2000) &#125;)&#125;// 迭代器，调用next()请求最新数据async function* timerGenerator () &#123; while (true) &#123; yield getData() &#125;&#125;// 业务代码，获取最新数据async function execute() &#123; const timer = timerGenerator() console.log(await timer.next()) // &#123;value: "MOCK DATA Thu Aug 30 2018 10:57:51 GMT+0800 (中国标准时间)", done: false&#125; console.log(await timer.next()) // &#123;value: "MOCK DATA Thu Aug 30 2018 10:57:53 GMT+0800 (中国标准时间)", done: false&#125; console.log(await timer.next()) // &#123;value: "MOCK DATA Thu Aug 30 2018 10:57:55 GMT+0800 (中国标准时间)", done: false&#125; console.log(await timer.next()) // &#123;value: "MOCK DATA Thu Aug 30 2018 10:57:57 GMT+0800 (中国标准时间)", done: false&#125;&#125;execute()]]></content>
      <tags>
        <tag>javascript 、es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular-React比较]]></title>
    <url>%2F2018%2F05%2F26%2FAngular-React%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[概述我对前端框架的看法是，同一个问题的多种解决方案，每个方案都有各有适应的场景和人群，但既然解决的是同一个问题，殊途同归，本文就是根据自己的使用经验，列举出Angular、React二者在不同中的相通之处 示例代码皆为伪代码，仅供理解 脉络 前端现代框架的一些基本逻辑: 组件化, 从原来代码级的复用提升到组件层，组件抽象出可复用的功能与UI，就像一个个零件 数据驱动，隐藏DOM操作的细节，页面工程化，整个页面就是一个大的机器，组件就是组成机器一个个的齿轮，受内外部数据驱动，影响周围的齿轮随之发生变化 工程化，集成脚手架等插件，使用路由统一入口 细节一. Angular 关键词： 模块化、组件化、依赖注入、脏检查 Angular应用是模块化的，一个NgModule（模块）就是一个容器，存放一些内聚代码块，如组件、指令、服务、管道等，提供导入、导出功能，每个Angular应用都会有一个根模块，引导根模块启动项目 组件可以通过路由器加载，也可以通过模板创建，组件是指令的一种，是带模版的指令，除了组件外，指令还有结构型指令和功能型指令二种，指令拥有生命周期钩子函数。在生命周期不同阶段被调用 依赖注入机制，注入器是树形结构，注入的服务是单例，子模块中定义的provider将被注册到根注入器，除非子模块为懒加载，懒加载模块单独生成一个注入器，除此之外，组件也拥有组件级注入器 Angular脏检查由ngZone触发，zone重写了一系列异步方法，如事件、定时器、封装了ajax请求，添加了回调钩子函数，在回调中进行数据变更检查，为组件设置onPush策略，组件将只在Input数据发生变化时触发检查，组件可注入changeDetection手动设置脏检查机制 其他，路由、HttpCLient + 拦截器机制， 视图封装模式（Native、Emulated、None），动态组件、dom操作（Renderer）、Rxjs管理异步事件流 二. React 关键词： 组件化、函数式编程、虚拟dom React 维护一颗组件树， 数据通过props从上往下单向流动，组件内部通过state保存状态，通过setState改变state的值，默认当props或state发生变化，组件重新渲染，PureReactComponent组件默认判断新旧props,state（浅引用判断）值，如果没有变化，不重新渲染，但过多diff操作同样消耗性能， 普通Component 可通过使用 shouldComponentUpdate生命周期钩子，返回true|false 来决定是否重新渲染组件，结合 immutable 对象可以更好的对性能进行优化 React 组件有3种创建方式（函数式、ES6、ES5），函数式无状态组件拥有更好的性能,每次重新渲染相当于重新执行一次函数,但如果需要用到state 、组件生命周期，则需要使用ES6方式, 通过ES5语法创建现已不推荐使用, jsx-函数式编程，可以用js来构建视图，可以使用临时变量、自带的流程控制、js当前作用域等，相比较于Angular的模板（Template）更为灵活 react利用key来识别组件，它是一种身份标识标识，当key发生变化，销毁原有组件，创建新组件，key没有变化，数据变化，重新渲染原组件 二者比较 数据流向： Angular 数据从上往下，单向流动，通过Output自定义事件与父组件通信 ， React 通过props从上往下，数据单向流动，通过state保存当前组件内部的状态，通过setState改变组件内部状态，与父组件通信通常通过状态提升来完成，常结合redux/mobx使用 不可变性：因为数据单向流动，所有子组件从父级接收的数据是不可变的（@Input 、props），Angular如果要对@Input传递的数据进行处理，可以用set去实现 Angular使用模板语法，通过结构型指令如ngIf、ngFor 实现条件渲染、列表展示, React通过jsx语法实现同样的功能，如下 1var &amp;&amp; &lt;div&gt;、datas.map(i,v) Angular 表单提供二种方式，模板驱动与响应式表单，前者通过模板语法与指令实现，后者由模型驱动，预先定义字段、校验项、初始值，提供校验方法，React 表单一般通过受控组件的方式实现 React 组件的props.children 类似于 Angular 的内容映射(通过ng-content指令实现) 避免重复渲染，性能优化，React 通常使用 shouldComponentUpdate + Immutable 对象减少重复渲染， Angular通常设置 changedetectionstrategy.onpush + Immutable 对象 集成第三方库时，常需要获取Dom对象，React使用 refs传递，Angular 通过ViewChild实现对dom节点的引用 12345678React : &lt;div ref=&#123;domRef&#125;&gt; // 通过this.domRef获取dom节点Angular : .ts: ViewChild(selector) domRef .html: &lt;div seletor&gt; Angular 相对React ，概念更多，给出了一个更复杂的解决方案，但同时，Angular提供了React没有的模块化、提供成体系的前端技术解决方案、引入typescript进行类型定义，对于大型协作项目的团队式开发和长期维护，是一个不错的选择，但正因为想要做的事情太多，不得不引入大量抽象概念，前期需要花费更多的时间 React 虽只提供了简单的API，但结合JSX语法，非常灵活且强大，但是灵活意味着容易犯错，相比较Angular，更容易把代码写的难以维护，对开发者个人的能力要求更高]]></content>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular实现元素双击可编辑]]></title>
    <url>%2F2018%2F02%2F28%2FAngular%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E5%8F%8C%E5%87%BB%E5%8F%AF%E7%BC%96%E8%BE%91%2F</url>
    <content type="text"><![CDATA[一.概述如果希望实现一个DOM元素，双击可编辑，失去焦点不可编辑，常用的方式，是绑定dbclick事件，当事件触发，将文本内容替换为表单元素，失去焦点，再替换为文本，这种做法固然简单，但如果要操作的dom元素太多，既要添加表单元素，还要监听dbclick、blur事件，代码不可避免会变得非常繁琐 所以我采取的做法是，抽象出一个指令，将指令注册为表单控件，实现双向绑定，结合DOM的contentEditable属性，只要在DOM元素上添加该指令即可具备该能力 使用1&lt;div appCanEdit [(ngModel)]="item.value"&gt;&lt;/div&gt; 效果 二.实现步骤1. 创建指令，实现 ControlValueAccessor接口 ControlValueAccessor是一个连接表单模型和视图（DOM元素）的接口，自定义的表单控件必须实现这个接口,它的作用是把 form 模型中值映射到视图中，当视图发生变化时，通知 form directives 或 form controls 12345678910111213141516171819202122232425@Directive(&#123; selector: '[appCanEdit]'&#125;)export class ElementCanEditDirective implements ControlValueAccessor &#123; _value; // callback function propagateChange = (value: any) =&gt; &#123; &#125;; // Writes a new value to the element ，temporarily store the value in '_value' writeValue(value: any) &#123; if (value) &#123; this._value = value; &#125; &#125; // when the control's value changes in the UI, call the callback function registerOnChange(fn: any) &#123; this.propagateChange = fn; &#125; registerOnTouched(fn: any) &#123; &#125; constructor( ) &#123; &#125;&#125; 2. 注册成为表单控件，将控件本身注册到DI框架成为一个可以让表单访问其值的控件12345678910@Directive(&#123; selector: '[appCanEdit]', providers: [ &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; ElementCanEditDirective), multi: true &#125; ],&#125;) 3. 通过@HostListener 为组件添加事件绑定，通过@HostBinding实现元素innerText随value而变化 当元素处于可编辑状态时，添加content-editable类样式，以便灵活控制样式 123456789101112131415161718192021@HostBinding() get innerText() &#123; return this._value;&#125;@HostListener('blur', ['$event.target'])onBlur(ele: HTMLElement) &#123; ele.contentEditable = 'false'; this._value = ele.innerText; this.propagateChange(this._value); this.render.removeClass(ele, 'content-editable');&#125;@HostListener('dblclick', ['$event.target'])dbClick(ele: HTMLElement) &#123; // plaintext-only ele.contentEditable = 'true'; ele.innerText = ele.innerText; ele.focus(); this.render.addClass(ele, 'content-editable');&#125; 三.完整代码1&lt;div appCanEdit [(ngModel)]="item.value"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import &#123; Component, OnInit, Input, EventEmitter, Directive, HostListener, HostBinding, Renderer2, forwardRef &#125; from '@angular/core';import &#123; ControlValueAccessor, NG_VALUE_ACCESSOR &#125; from '@angular/forms';/** * 让DOM元素可编辑 * 可在元素上使用 ngModel * @export * @class ElementCanEditDirective * @implements &#123;ControlValueAccessor&#125; */@Directive(&#123; selector: '[appCanEdit]', providers: [ &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; ElementCanEditDirective), multi: true &#125; ],&#125;)export class ElementCanEditDirective implements ControlValueAccessor &#123; _value; // callback function propagateChange = (value: any) =&gt; &#123; &#125;; // Writes a new value to the element ，temporarily store the value in '_value' writeValue(value: any) &#123; if (value) &#123; this._value = value; &#125; &#125; // when the control's value changes in the UI, call the callback function registerOnChange(fn: any) &#123; this.propagateChange = fn; &#125; registerOnTouched(fn: any) &#123; &#125; @HostBinding() get innerText() &#123; return this._value; &#125; @HostListener('blur', ['$event.target']) onBlur(ele: HTMLElement) &#123; ele.contentEditable = 'false'; this._value = ele.innerText; this.propagateChange(this._value); this.render.removeClass(ele, 'content-editable'); &#125; @HostListener('dblclick', ['$event.target']) dbClick(ele: HTMLElement) &#123; ele.contentEditable = 'true'; ele.innerText = ele.innerText; ele.focus(); this.render.addClass(ele, 'content-editable'); &#125; constructor( private render: Renderer2 ) &#123; &#125;&#125;]]></content>
      <tags>
        <tag>Angular , React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs到Angular的变化]]></title>
    <url>%2F2017%2F10%2F28%2FAngularJs%E5%88%B0Angular%E7%9A%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[概述关于AngularJs、Angular 一脉相承的思路与不同之处 以下只是个人使用过程中的的一些感受,具体二者之间的差别参考 [官方文档](https://angular.cn/guide/ajs-quick-reference) 细节 引入脚手架，提供Typescript es6超集 , 支持 import export ,不需额外引入模块加载器 将组件和指令二者剥离开来，前者组成页面，后者分为结构性指令和功能性指令, 不再支持replace等 移除controller, $scope等 provider，service,factory 统一为 service, 减少理解上的困惑 angularJs 只有一个注入器，所有服务都是单例，Angular的注入器则是一个树状结构，可以为一个注入对象实现不同的实例（在不同的注入器上） controller &lt;=&gt; component 一定意义上等价，都封装了model实体模型，指定html模板,业务逻辑，也都挂靠在模块上 在setTimeout等异步执行环境中不再需要手动调用$scope.$apply() , angular的代码都运行在 zone中，通过为异步方法打补丁的方式，在方法执行完后自动的执行数据检查，如果使用第三方类库，存在异步操作，想要纳入Angular管理，可以通过以下方式实现 123this.ngZone.run(() =&gt; &#123; this.service.uploadEvent.emit(data);&#125;);]]></content>
      <tags>
        <tag>Angular, AngularJs</tag>
      </tags>
  </entry>
</search>
