<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DvaJS model复用的方案]]></title>
    <url>%2F2018%2F08%2F30%2FDvaJS%E5%AE%9E%E7%8E%B0model%E5%A4%8D%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Dva 下 model 复用 （一个model同时对应多个业务模块，业务模块间数据互不影响）前置知识: dva =&gt; 一个基于 redux 和 redux-saga 的数据流方案 react =&gt; 高阶组件的定义 1. 示例描述：多Tab结构， 存在A、B、C 业务模块，数据不同，业务逻辑一致，希望实现代码复用 2. 示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// router.js // 1. 动态加载 model 和 路由组件&#123; path: 'product', getComponent(nextState, cb) &#123; require.ensure([], require =&gt; &#123; // 从location 中获取业务类型 type const type = nextState.location.query.type // 加载model并挂载到dva实例上 注意：require后接了()，因为返回的是一个函数，函数执行返回真正将被挂载的model对象 app.model(require('./models/product')(type)) // 加载路由组件 require 返回的也是一个函数，函数执行返回一个React组件（高阶组件，在真正的路由组件上包了一层） cb(null, require('./routes/product')(type)) &#125;, 'product') &#125;&#125;// models/product.js // 2. 根据type 动态生成 modelexport default function modelGenerate(type) &#123; return &#123; namespace: `products$&#123;type&#125;`, state: &#123; list: [] &#125;, reducers: &#123; &#125; effects: &#123; &#125; &#125;&#125;;// routes/product.jsx // 3. 根据type 动态返回 新的React组件（对业务组件进行包装）export default function routeGenarate(type) &#123; // 根据type找到命名空间 const namespace = `products$&#123;type&#125;` function ProductWrapper() &#123; return class extends React.Component &#123; render() &#123; return &lt;Products &#123;...this.props&#125; /&gt; &#125; &#125; &#125; // 根据 namespace(命名空间) 从redux store 获取对应的model实例数据 ，并命名为 productModel return connect(store =&gt; (&#123; productModel: store[namespace] &#125;))(ProductWrapper())&#125;// 业务组件 从 props.productModel 获取数据const Products = (&#123; dispatch, productModel &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;ProductList list=&#123;productModel.list&#125; /&gt; &lt;/div&gt; );&#125;]]></content>
      <tags>
        <tag>React, DvaJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator与async、await[借鉴自MDN]]]></title>
    <url>%2F2018%2F08%2F30%2FGenerator%E4%B8%8Easync%2Cawait%2F</url>
    <content type="text"><![CDATA[一. ES6 Generator(生成器) 语法function* 用于定义一个生成器函数（generator function），它返回一个Generator对象, Generator对象被创建后，通过调用next()方法获取值 yield 关键字用来暂停和恢复一个生成器函数 yield关键字使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个基于生成器的版本的return关键字 yield关键字实际返回一个IteratorResult对象，它有两个属性，value和done。value属性是对yield表达式求值的结果，而done是false，表示生成器函数尚未完全完成。 一旦遇到 yield 表达式，生成器的代码将被暂停运行，直到生成器的 next() 方法被调用。每次调用生成器的next()方法时，生成器都会恢复执行，直到达到以下某个值: yield，导致生成器再次暂停并返回生成器的新值。 下一次调用next()时，在yield之后紧接着的语句继续执行。 throw用于从生成器中抛出异常。这让生成器完全停止执行，并在调用者中继续执行，正如通常情况下抛出异常一样。 到达生成器函数的结尾；在这种情况下，生成器的执行结束，并且IteratorResult给调用者返回undefined并且done为true。 到达return 语句。在这种情况下，生成器的执行结束，并将IteratorResult返回给调用者，其值是由return语句指定的，并且done 为true。 123456789101112// 示例：function* countAppleSales () &#123; var saleList = [3, 7, 5]; for (var i = 0; i &lt; saleList.length; i++) &#123; yield saleList[i]; &#125;&#125;var appleStore = countAppleSales(); // Generator &#123; &#125;console.log(appleStore.next()); // &#123; value: 3, done: false &#125;console.log(appleStore.next()); // &#123; value: 7, done: false &#125;console.log(appleStore.next()); // &#123; value: 5, done: false &#125;console.log(appleStore.next()); // &#123; value: undefined, done: true &#125; ##### 注意： 1. 不能在forEach等方法中直接使用yield，因为forEach等接受一个函数作为参数，yield外层执行环境不是生成器函数，所以会报语法错误，错误示例如下 12345function* nameGenerator() &#123; ['Hellon','Nancy'].forEach(item =&gt; &#123; yield item // =&gt; Uncaught SyntaxError: Unexpected identifier &#125;)&#125; 2. 也可作为对象属性存在，通过如下方式定义 1*countAppleSales() &#123;&#125; yield* 表达式用于委托给另一个generator 或可迭代对象。 二. Async function： async function 声明将定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。但是如果你的代码使用了异步函数，它的语法和结构会更像是标准的同步函数 1). 当调用一个 async 函数时，会返回一个 Promise 对象。当这个 async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值；当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值。 2). async 函数中可能会有 await 表达式，这会使 async 函数暂停执行，等待表达式中的 Promise 解析完成后继续执行 async 函数并返回解决结果 await 操作符用于等待一个Promise 对象。它只能在异步函数 async function 中使用 1). await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行 async function。 2). 若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。 3). 另外，如果 await 操作符后的表达式的值不是一个 Promise，那么该值将被转换为一个已正常处理的 Promise。 三. Generator 结合 async/await1234567891011121314151617181920212223242526// 模拟发起请求，获取数据function getData() &#123; return new Promise((resolve) =&gt; &#123; data = `MOCK DATA $&#123;new Date()&#125;` setTimeout(_ =&gt; &#123; resolve(data) &#125;, 2000) &#125;)&#125;// 迭代器，调用next()请求最新数据async function* timerGenerator () &#123; while (true) &#123; yield getData() &#125;&#125;// 业务代码，获取最新数据async function execute() &#123; const timer = timerGenerator() console.log(await timer.next()) // &#123;value: "MOCK DATA Thu Aug 30 2018 10:57:51 GMT+0800 (中国标准时间)", done: false&#125; console.log(await timer.next()) // &#123;value: "MOCK DATA Thu Aug 30 2018 10:57:53 GMT+0800 (中国标准时间)", done: false&#125; console.log(await timer.next()) // &#123;value: "MOCK DATA Thu Aug 30 2018 10:57:55 GMT+0800 (中国标准时间)", done: false&#125; console.log(await timer.next()) // &#123;value: "MOCK DATA Thu Aug 30 2018 10:57:57 GMT+0800 (中国标准时间)", done: false&#125;&#125;execute()]]></content>
      <tags>
        <tag>javascript 、es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular-React比较]]></title>
    <url>%2F2018%2F05%2F26%2FAngular-React%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[示例代码皆为伪代码，仅供理解 Angular 模块化、组件化、依赖注入、脏检查 Angular应用是模块化的， 一个NgModule就是一个容器，存放一些内聚代码块，如组件、指令、服务、管道等，提供导入、导出功能，每个Angular应用都会有一个根模块，引导根模块启动项目 组件可以通过路由器加载，也可以通过模板创建，组件是指令的一种，是带模版的指令，除了组件外，指令还有结构型指令和功能型指令二种，指令拥有生命周期钩子函数。在生命周期不同阶段被调用 依赖注入机制，注入器是树形结构，注入的服务是单例，子模块中定义的provider将被注册到根注入器，除非子模块为懒加载，懒加载模块单独生成一个注入器，除此之外，组件也拥有组件级注入器 Angular脏检查由ngZone触发，zone重写了一系列异步方法，如事件、定时器、封装了ajax请求，添加了回调钩子函数，在回调中进行数据变更检查，为组件设置onPush策略，组件将只在Input数据发生变化时触发检查，组件可注入changeDetection手动设置脏检查机制 其他，路由、HttpCLient + 拦截器机制， 视图封装模式（Native、Emulated、None），动态组件、dom操作（Renderer）、Rxjs管理异步事件流 React 组件化、函数式编程、虚拟dom React 维护一颗组件树， 数据通过props从上往下单向流动，组件内部通过state保存状态，通过setState改变state的值，默认当props或state发生变化，组件重新渲染，PureReactComponent组件默认判断新旧props,state（浅引用判断）值，如果没有变化，不重新渲染，但过多diff操作同样消耗性能， 普通Component 可通过使用 shouldComponentUpdate生命周期钩子，返回true|false 来决定是否重新渲染组件，结合 immutable 对象可以更好的对性能进行优化 React 组件有3种创建方式（函数式、ES6、ES5），函数式无状态组件拥有更好的性能,每次重新渲染相当于重新执行一次函数,但如果需要用到state 、组件生命周期，则需要使用ES6方式, 通过ES5语法创建现已不推荐使用, jsx-函数式编程，可以用js来构建视图，可以使用临时变量、自带的流程控制、js当前作用域等，相比较于Angular的模板（Template）更为灵活 react利用key来识别组件，它是一种身份标识标识，当key发生变化，销毁原有组件，创建新组件，key没有变化，数据变化，重新渲染原组件 二者差异 数据流向： Angular 数据从上往下，单向流动，通过Output自定义事件与父组件通信 ， React 通过props从上往下，数据单向流动，通过state保存当前组件内部的状态，通过setState改变组件内部状态，与父组件通信通常通过状态提升来完成，或使用redux 不可变性： @Input 、props 传递的数据都是不可变的（Angular官方文档并没有明确提示，但我从来没这么写过，就算可以也不建议，如果一定要对@Input传递的数据进行处理，可以用set去实现） Angular 中的结构型指令如ngIf、ngFor , React通过如下jsx语法实现同样的功能 1var &amp;&amp; &lt;div&gt;、datas.map(i,v) Angular 表单提供二种方式，模板驱动与响应式表单，前者通过模板语法与指令实现，后者由模型驱动，预先定义字段、校验项、初始值，提供校验方法，React 表单一般通过受控组件的方式实现 React 组件的props.children 类似于 Angular 的内容映射(通过ng-content指令实现) 避免重复渲染，性能优化，React 通常使用 shouldComponentUpdate + Immutable 对象减少重复渲染， Angular通常设置 changedetectionstrategy.onpush + Immutable 对象 获取Dom对象，React使用 refs传递，Angular 通过ViewChild实现对dom节点的引用 12345678React : &lt;div ref=&#123;domRef&#125;&gt; // 通过this.domRef获取dom节点Angular : .ts: ViewChild(selector) domRef .html: &lt;div seletor&gt; Angular 相对React ，概念更多，给出了一个更复杂的解决方案，但同时，Angular提供了React没有的模块化、提供成体系的前端技术解决方案、引入typescript进行类型定义，对于大型协作项目的团队式开发和长期维护，是一个不错的选择]]></content>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular实现元素双击可编辑]]></title>
    <url>%2F2018%2F02%2F28%2FAngular%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E5%8F%8C%E5%87%BB%E5%8F%AF%E7%BC%96%E8%BE%91%2F</url>
    <content type="text"><![CDATA[实现目标 新建指令，将指令注册为表单控件，在元素上使用，可以通过ngModel实现双向绑定，双击可编辑元素内文字内容，失去焦点不可编辑 使用1&lt;div appCanEdit [(ngModel)]="item.value"&gt;&lt;/div&gt; 效果 实现步骤1. 创建指令，实现 ControlValueAccessor接口 ControlValueAccessor是一个连接表单模型和视图（DOM元素）的接口，自定义的表单控件必须实现这个接口,它的作用是把 form 模型中值映射到视图中，当视图发生变化时，通知 form directives 或 form controls 12345678910111213141516171819202122232425@Directive(&#123; selector: '[appCanEdit]'&#125;)export class ElementCanEditDirective implements ControlValueAccessor &#123; _value; // callback function propagateChange = (value: any) =&gt; &#123; &#125;; // Writes a new value to the element ，temporarily store the value in '_value' writeValue(value: any) &#123; if (value) &#123; this._value = value; &#125; &#125; // when the control's value changes in the UI, call the callback function registerOnChange(fn: any) &#123; this.propagateChange = fn; &#125; registerOnTouched(fn: any) &#123; &#125; constructor( ) &#123; &#125;&#125; 2. 注册成为表单控件，将控件本身注册到DI框架成为一个可以让表单访问其值的控件12345678910@Directive(&#123; selector: '[appCanEdit]', providers: [ &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; ElementCanEditDirective), multi: true &#125; ],&#125;) 3. 通过@HostListener 为组件添加事件绑定，通过@HostBinding实现元素innerText随value而变化 当元素处于可编辑状态时，添加content-editable类样式，以便灵活控制样式 123456789101112131415161718192021@HostBinding() get innerText() &#123; return this._value;&#125;@HostListener('blur', ['$event.target'])onBlur(ele: HTMLElement) &#123; ele.contentEditable = 'false'; this._value = ele.innerText; this.propagateChange(this._value); this.render.removeClass(ele, 'content-editable');&#125;@HostListener('dblclick', ['$event.target'])dbClick(ele: HTMLElement) &#123; // plaintext-only ele.contentEditable = 'true'; ele.innerText = ele.innerText; ele.focus(); this.render.addClass(ele, 'content-editable');&#125; 完整代码1&lt;div appCanEdit [(ngModel)]="item.value"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import &#123; Component, OnInit, Input, EventEmitter, Directive, HostListener, HostBinding, Renderer2, forwardRef &#125; from '@angular/core';import &#123; ControlValueAccessor, NG_VALUE_ACCESSOR &#125; from '@angular/forms';/** * 让DOM元素可编辑 * 可在元素上使用 ngModel * @export * @class ElementCanEditDirective * @implements &#123;ControlValueAccessor&#125; */@Directive(&#123; selector: '[appCanEdit]', providers: [ &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; ElementCanEditDirective), multi: true &#125; ],&#125;)export class ElementCanEditDirective implements ControlValueAccessor &#123; _value; // callback function propagateChange = (value: any) =&gt; &#123; &#125;; // Writes a new value to the element ，temporarily store the value in '_value' writeValue(value: any) &#123; if (value) &#123; this._value = value; &#125; &#125; // when the control's value changes in the UI, call the callback function registerOnChange(fn: any) &#123; this.propagateChange = fn; &#125; registerOnTouched(fn: any) &#123; &#125; @HostBinding() get innerText() &#123; return this._value; &#125; @HostListener('blur', ['$event.target']) onBlur(ele: HTMLElement) &#123; ele.contentEditable = 'false'; this._value = ele.innerText; this.propagateChange(this._value); this.render.removeClass(ele, 'content-editable'); &#125; @HostListener('dblclick', ['$event.target']) dbClick(ele: HTMLElement) &#123; ele.contentEditable = 'true'; ele.innerText = ele.innerText; ele.focus(); this.render.addClass(ele, 'content-editable'); &#125; constructor( private render: Renderer2 ) &#123; &#125;&#125;]]></content>
      <tags>
        <tag>Angular , React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs到Angular的变化]]></title>
    <url>%2F2017%2F10%2F28%2FAngularJs%E5%88%B0Angular%E7%9A%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[以下只是个人使用过程中的的一些感受,具体二者之间的差别参考 官方文档 Typescript es6超集 , 支持 import export ,不需额外引入模块加载器 将组件和指令二者剥离开来，前者组成页面，后者分为结构性指令和功能性指令, 不再支持replace等 移除controller, $scope等 provider，service,factory 统一为 service, 减少理解上的困惑 angularJs 只有一个注入器，所有服务都是单例，Angular的注入器则是一个树状结构，可以为一个注入对象实现不同的实例（在不同的注入器上） controller &lt;=&gt; component 一定意义上等价，都封装了model实体模型，指定html模板,业务逻辑，也都挂靠在模块上 在setTimeout等异步执行环境中不再需要手动调用$scope.$apply() , angular的代码都运行在 zone中，通过为异步方法打补丁的方式，在方法执行完后自动的执行数据检查，如果使用第三方类库，存在异步操作，想要纳入Angular管理，可以通过以下方式实现 123this.ngZone.run(() =&gt; &#123; this.service.uploadEvent.emit(data);&#125;);]]></content>
      <tags>
        <tag>Angular, AngularJs</tag>
      </tags>
  </entry>
</search>
